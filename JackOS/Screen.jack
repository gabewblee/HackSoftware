/**
 * Screen class provides low-level graphics operations for the JackOS.
 * 
 * This class manages the 512x256 pixel screen display through direct
 * memory manipulation. It provides functions for drawing pixels, lines,
 * rectangles, and circles using various graphics algorithms. The screen
 * memory is organized as 8192 words, with each word containing 16 pixels.
 * 
 * Screen Layout:
 * - 512 pixels wide by 256 pixels tall
 * - Screen memory starts at address 16384
 * - 32 words per row (16 pixels per word)
 * - Each pixel can be black (1) or white (0)
 * 
 * Key Features:
 * - Pixel-level drawing with color control
 * - Line drawing using Bresenham's algorithm
 * - Rectangle and circle drawing
 * - Bit mask operations for efficient pixel manipulation
 * - Coordinate validation and error handling
 */
class Screen {
    static Array masks;    // Bit masks for pixel operations (2^0 to 2^15)
    static int base;       // Base address of screen memory (16384)
    static boolean color;  // Current drawing color (true=black, false=white)

    /**
     * Initializes the Screen system.
     * 
     * Sets up the screen base address, initializes the drawing color to black,
     * and creates a lookup table of bit masks for efficient pixel operations.
     * The masks array contains powers of 2 from 1 to 32768.
     */
    function void init() {
        var int i;
        let base = 16384;
        let color = true; 
        let masks = Array.new(17);
        let masks[0] = 1;
        let i = 1;
        while (i < 17) {
            let masks[i] = masks[i - 1] + masks[i - 1];
            let i = i + 1;
        }
        return;
    }

    /**
     * Clears the entire screen by setting all pixels to white.
     * 
     * Writes zeros to all 8192 words in screen memory, effectively
     * clearing the entire 512x256 pixel display.
     */
    function void clearScreen() {
        var int i;
        let i = 0;
        while (i < 8192) {
            do Memory.poke(base + i, 0);
            let i = i + 1;
        }
        return;
    }

    /**
     * Sets the current drawing color.
     * 
     * @param isBlack True to draw in black, false to draw in white
     */
    function void setColor(boolean isBlack) {
        let color = isBlack;
        return;
    }

    /**
     * Updates a specific bit in screen memory.
     * 
     * Reads the current word from screen memory, applies the bit mask
     * according to the current color setting, and writes the result back.
     * 
     * @param addr The memory address within screen memory
     * @param mask The bit mask to apply
     */
    function void updateLocation(int addr, int mask) {
        var int word;
        let word = Memory.peek(base + addr);
        if (color) {
            let word = word | mask;
        } else {
            let word = word & (~mask);
        }
        do Memory.poke(base + addr, word);
        return;
    }

    /**
     * Draws a single pixel at the specified coordinates.
     * 
     * Calculates the memory address and bit position for the given
     * pixel coordinates and updates the screen memory accordingly.
     * 
     * @param x The x-coordinate (0-511)
     * @param y The y-coordinate (0-255)
     * @throws Sys.error(7) if coordinates are out of bounds
     */
    function void drawPixel(int x, int y) {
        var int wordX, bit, addr;
        if ((x < 0) | (x > 511) | (y < 0) | (y > 255)) {
            do Sys.error(7);
            return;
        }
        let wordX = Math.divide(x, 16);
        let bit = x - (Math.multiply(wordX, 16));
        let addr = Math.multiply(y, 32) + wordX;
        do Screen.updateLocation(addr, masks[bit]);
        return;
    }

    /**
     * Helper function for line drawing that handles coordinate swapping.
     * 
     * Used by the line drawing algorithm to handle steep lines where
     * x and y coordinates need to be swapped for proper pixel placement.
     * 
     * @param a The first coordinate
     * @param b The second coordinate
     * @param swapped True if coordinates should be swapped (b,a), false for (a,b)
     */
    function void drawConditional(int a, int b, boolean swapped) {
        if (swapped) {
            do Screen.drawPixel(b, a);
        } else {
            do Screen.drawPixel(a, b);
        }
        return;
    }

    /**
     * Draws a line between two points using Bresenham's line algorithm.
     * 
     * Implements an efficient line drawing algorithm that handles both
     * steep and shallow lines. The algorithm ensures that lines are
     * drawn correctly regardless of their orientation.
     * 
     * @param x0 The x-coordinate of the starting point
     * @param y0 The y-coordinate of the starting point
     * @param x1 The x-coordinate of the ending point
     * @param y1 The y-coordinate of the ending point
     * @throws Sys.error(8) if coordinates are out of bounds
     */
    function void drawLine(int x0, int y0, int x1, int y1) {
        var int dx, dy, steep, sx, sy, err, x, y;
        if ((x0 < 0) | (x1 > 511) | (y0 < 0) | (y1 > 255)) {
            do Sys.error(8);
            return;
        }

        let dx = Math.abs(x1 - x0);
        let dy = Math.abs(y1 - y0);
        let steep = (dy > dx);

        if ((steep & (y1 < y0)) | ((~steep) & (x1 < x0))) {
            let x = x0; let x0 = x1; let x1 = x;
            let y = y0; let y0 = y1; let y1 = y;
            let dx = Math.abs(x1 - x0);
            let dy = Math.abs(y1 - y0);
        }

        let sx = 1;
        let sy = 1;
        if (steep) {
            if (x1 < x0) { let sx = -1; } else { let sx = 1; }
            if (y1 < y0) { let sy = -1; } else { let sy = 1; }
        } else {
            if (x1 < x0) { let sx = -1; } else { let sx = 1; }
            if (y1 < y0) { let sy = -1; } else { let sy = 1; }
        }

        if (steep) {
            let err = (2 * dx) - dy;
            let x = x0; let y = y0;
            while ((y < y1) | (y = y1)) {
                do Screen.drawConditional(x, y, true);
                if (err > 0) { let x = x + sx; let err = err - (2 * dy); }
                let err = err + (2 * dx);
                let y = y + 1;
            }
        } else {
            let err = (2 * dy) - dx;
            let x = x0; let y = y0;
            while ((x < x1) | (x = x1)) {
                do Screen.drawConditional(x, y, false);
                if (err > 0) { let y = y + sy; let err = err - (2 * dx); }
                let err = err + (2 * dy);
                let x = x + 1;
            }
        }
        return;
    }

    /**
     * Draws a horizontal line at the specified y-coordinate.
     * 
     * Draws a line from x1 to x2 at the given y-coordinate. Automatically
     * handles coordinate ordering (left to right) and clips the line to
     * screen boundaries. Used as a building block for rectangle and circle drawing.
     * 
     * @param y The y-coordinate of the horizontal line
     * @param x1 The starting x-coordinate
     * @param x2 The ending x-coordinate
     */
    function void drawHorizontal(int y, int x1, int x2) {
        var int left, right, x;
        let left = Math.min(x1, x2);
        let right = Math.max(x1, x2);
        if ((y < 0) | (y > 255) | (left > 511) | (right < 0)) {
            return;
        }
        if (left < 0) { let left = 0; }
        if (right > 511) { let right = 511; }
        let x = left;
        while ((x < right) | (x = right)) {
            do Screen.drawPixel(x, y);
            let x = x + 1;
        }
        return;
    }

    /**
     * Draws a filled rectangle between two corner points.
     * 
     * Draws a rectangle by filling horizontal lines from y1 to y2,
     * with each line spanning from x1 to x2. The rectangle is filled
     * with the current drawing color.
     * 
     * @param x1 The x-coordinate of the first corner
     * @param y1 The y-coordinate of the first corner
     * @param x2 The x-coordinate of the second corner
     * @param y2 The y-coordinate of the second corner
     * @throws Sys.error(9) if coordinates are invalid or out of bounds
     */
    function void drawRectangle(int x1, int y1, int x2, int y2) {
        var int yStart, yEnd, y;
        if ((x1 > x2) | (y1 > y2) | (x1 < 0) | (x2 > 511) | (y1 < 0) | (y2 > 255)) {
            do Sys.error(9);
            return;
        }
        let yStart = y1;
        let yEnd = y2;
        let y = yStart;
        while ((y < yEnd) | (y = yEnd)) {
            do Screen.drawHorizontal(y, x1, x2);
            let y = y + 1;
        }
        return;
    }

    /**
     * Helper function for circle drawing that uses symmetry.
     * 
     * Draws eight symmetric points around a circle center using the
     * current (x,y) offset. This function is used by the circle drawing
     * algorithm to efficiently draw the entire circle by only calculating
     * one-eighth of the points.
     * 
     * @param cx The x-coordinate of the circle center
     * @param cy The y-coordinate of the circle center
     * @param x The x-offset from center
     * @param y The y-offset from center
     */
    function void drawSymetric(int cx, int cy, int x, int y) {
        do Screen.drawHorizontal(cy - y, cx - x, cx + x);
        do Screen.drawHorizontal(cy + y, cx - x, cx + x);
        do Screen.drawHorizontal(cy - x, cx - y, cx + y);
        do Screen.drawHorizontal(cy + x, cx - y, cx + y);
        return;
    }

    /**
     * Draws a circle using the midpoint circle algorithm.
     * 
     * Implements an efficient circle drawing algorithm that uses
     * symmetry to draw only one-eighth of the circle and mirrors
     * the points to complete the full circle.
     * 
     * @param cx The x-coordinate of the circle center
     * @param cy The y-coordinate of the circle center
     * @param r The radius of the circle
     * @throws Sys.error(12) if center coordinates are out of bounds
     * @throws Sys.error(13) if circle would extend beyond screen boundaries
     */
    function void drawCircle(int cx, int cy, int r) {
        var int x, y, d;
        if ((cx < 0) | (cx > 511) | (cy < 0) | (cy > 255)) {
            do Sys.error(12);
            return;
        }
        if (((cx - r) < 0) | ((cx + r) > 511) | ((cy - r) < 0) | ((cy + r) > 255)) {
            do Sys.error(13);
            return;
        }
        let x = 0;
        let y = r;
        let d = 1 - r;
        do Screen.drawSymetric(cx, cy, x, y);
        while (y > x) {
            if (d < 0) {
                let d = d + (2 * x) + 3;
            } else {
                let d = d + (2 * (x - y)) + 5;
                let y = y - 1;
            }
            let x = x + 1;
            do Screen.drawSymetric(cx, cy, x, y);
        }
        return;
    }
}

